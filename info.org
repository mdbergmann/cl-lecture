#+AUTHOR: Manfred Bergmann
#+TITLE: Common Lisp - oldie but goldie
#+OPTIONS: |:t \n:t

* Intro
  This article should be a brief introduction to Common Lisp. Brief, because Common Lisp is a rather large and complex system. It has many features. I will try to concentrate on the basics and some exceptional features that you likely find nowhere else.
  
** how did I come to Common Lisp
   I have been working with various languages and runtimes since the start oif my career 22 years ago.
   Beginning of 2019 I wanted to fin something else to closely look into that is not JVM based (which I'm mostly been working with since close to 20 years starting with Java 1.1).
   For some reason, which I can't recall, I haven't been really introduced to Lisps, ever. I also can't recall why 2019 I thought that I should take a look at Lisps.
   So I took a look at Clojure first. Clojure is a great language but it was again on the JVM. I wanted something native, or at least some other runtime.
   After some excursions to Erlang, Elixir and Lisp Flavoured Erlang I finally found Common Lisp and didn't regret it.
   
** brief history
   First drafts of Common Lisp appeared 1984. While mostly a successor of Maclisp it tried to
   unify and standardize Maclisp and the various other successors of Maclisp.
   In 1994 Common Lisp was an ANSI standard.
   
** age advantages
   Since then the standard hasn't changed. That can of course be seen as a bad thing.
   But actually I believe it is a good thing. It is even today surprisingly 'modern' and has many features of todays languages, partially even more features than 'modern' languages.
   Common Lisp is a quite large and complex package. After this long time there are of course some dusty corners. But all in all it is still very attractive and has an active community.
   Because the standard didn't change since 1994 any code written since then should still be compile- and runnable on modern compilers and runtime implementarions, where there are still a few (see below).
   
* Basics
  Let me run through some of the basic features of Common Lisp. Those basic features are likely also available in other languages. Common Lisp also has some unique features that I'll be talking about later.

** TODO lists
   Since the name 'Lisp' is an abbrevation for List Processing we should have a look at lists. Lists are the corner stone of the Lisp language because every Lisp construct is a list also called s-expression.

   
** functions
   Functions are nothing special. Every language knows them. They are sometimes also known as subroutines or procedures. There are of course fine grained meaning differences but that should be the talk for some other time.

   A simple function (which does nothing) definition looks like this:

   #+BEGIN_SRC lisp
     (defun my-fun ())
     (my-fun)
   #+END_SRC

   #+RESULTS:
   : NIL

   A function in Common Lisp always returns something, even if not explicitly done. This simple function just returns ~NIL~, which in Common Lisp has two meanings. a) it has a boolean meaning of =false= and b) it means the empty list equal to ~'()~.
   
   Common Lisp provides a very sophisticated set of features to structure function arguments.

*** Mantatory arguments
    Mandatory arguments are simply added to the list construct following the function name. This list construct that represents the arguments is commonly knows as /lambda list/.
    
    #+BEGIN_SRC lisp
      (defun my-fun (arg1 arg2)
        (list arg1 arg2))
      (my-fun "Hello" "World")
    #+END_SRC

    #+RESULTS:
    | Hello | World |
    
*** Optional arguments
    Optional arguments are defined using the ~&optional~ keyword:

    #+BEGIN_SRC lisp
      (defun my-fun (arg1 &optional opt1 (opt2 "buzz" opt2-p))
        (list arg1 opt1 opt2 opt2-p))
      (list
       (my-fun "foo")
       (my-fun "foo" "bar")
       (my-fun "foo" "bar" "my-buzz"))
    #+END_SRC

    #+RESULTS:
    | foo | NIL | buzz    | NIL |
    | foo | bar | buzz    | NIL |
    | foo | bar | my-buzz | T   |

    The first optional =opt1= does not have a default value, so if undefined it'll be ~NIL~. The second optional =opt2= when undefined is populated with the given default value "buzz". The  optional ~opt2-p~ predicate indicates whether the =opt2= parameter has been given or not. Sometimes this is useful in succeeding code.
    
*** Key arguments
    =key= arguments are similar as named arguments in other languages. The ordering of =key= arguments is not important and is not enforced. They are defined with a the ~&key~ keyword:

    #+BEGIN_SRC lisp
      (defun my-fun (&key key1 (key2 "bar" key2-p))
        (list key1 key2 key2-p))
      (list
       (my-fun)
       (my-fun :key1 "foo")
       (my-fun :key1 "foo" :key2 "buzz"))
    #+END_SRC

    #+RESULTS:
    | NIL | Foo  | NIL |
    | Bar | Foo  | NIL |
    | Bar | Buzz | T   |

    =key= arguments are optional. Similarly as ~&optional~ arguments a default value can be configured and a predicate that indicates whether the parameter was provided or not. Defining =key2-p= is optional.

*** Rest arguments
    =rest= arguments are arguments that have not already been captured by mandatory, optional, or key. So they form a rest. This rest is available in the body as a list. Defined by ~rest~ keyword. =rest= arguments are sometimes usefull to pass them on to ~apply~ function.

    #+BEGIN_SRC lisp
      (defun my-fun (arg1 &optional opt1 &rest rest)
              (list arg1 opt1 rest))
      (list
       (my-fun "foo" :rest1 "rest1" :key1 "buzz")
       (my-fun "foo" "opt1" :rest1 "rest1" :key1 "buzz"))
    #+END_SRC

    #+RESULTS:
    | foo | :REST1 | (rest1 :KEY1 buzz)        |
    | foo | opt1   | (:REST1 rest1 :KEY1 buzz) |

    
*** Mixing arguments
    As you can see it is possible to mix ~optional~, ~key~ and ~rest~ arguments. However, some care must be taken with mixing =optional= and =key= because the key of the =key= argument could be taken as a the =optional= argument. Similarly with =rest= and =key= arguments as can be seen in the examples above. In most use-cases you'd either have =optional= or =key= together with madatory arguments.
   
** lambdas
   Lambdas are anonymus functions defined at runtime. Other than that they are similar to =defun=s, regular/named functions. They can be used in place of a function name like this:

   #+BEGIN_SRC lisp
     ((lambda (x) x) "foo")  ;; returns "foo"
   #+END_SRC

   #+RESULTS:
   : foo

   In which case the lambda is immediately evaluated. The function 'is applied' on the value "foo", represented as the argument x. The function then returns x.
   In other cases, i.e. when a lambda is bound to a variable one need to evaluate the lambda using =funcall=:

   #+BEGIN_SRC lisp
     (let ((my-fun (lambda (x) x)))
       (funcall my-fun "foo"))
   #+END_SRC

   #+RESULTS:
   : foo

   This is in contrast to Scheme, or other Lisp-1s, where also =my-fun= can be used in place of the function name and would just be evaluated as a function.
   Common Lisp is a Lisp-2, which means that there are separate environments for variables and functions. In the above example =my-fun= is a variable. In order to evaluate it as a function one one has to use =funcall=.

   Lambdas are first-class objects in Common Lisp which means they can be created at runtime, bound to variables and passed around as function arguments or function results:

   #+BEGIN_SRC lisp
     (defun my-lambda ()
       (lambda (y) y))
     (list (type-of (my-lambda)) 
           (funcall (my-lambda) "bar"))
   #+END_SRC

   #+RESULTS:
   | function | bar |

   The "Lambda-calculus" (Alonzo Church, 1930) is a mathematical formal system based on variables, function abstractions (lambda expressions) and applying those using substitution. This can be used for any kind of computation and is Turing machine equivalent (or can be used to simulate a Turing machine).
   So if one would stack/nest lambda expression in lambda expression in lambda expression and so on, where a lambda expression is bound to a variable and the computation of this again substitutes a variable, you could have such a lambda-calculus.
   This is of course not so practical and hard to read but this alone would be enough to calculate anything that is calculatable.
   
** macros
  Macros are an essential part in Common Lisp. One should not confuse Lisp macros with C macros which just do textual replacement. Common Lisp macros are extremely powerful.
  In short, macros are constructs that generate and/or manipulate code. Lisp macros still stand out in contrast to other languages because Lisp macros just generate and manipulate ordinary Lisp code where as other languages use an AST (Abstract Syntax Tree) representation of the code and hence the macros must deal with the AST. In Lisp, Lisp is the AST.

  Macros could replace many functions where functions are just helper functions. But function can never replace macros. There is a fundamental difference.
  The arguments to macros are not immediately evaluated but passed to the macro as code. For example let's create a simple =when= replacement:

  #+BEGIN_SRC lisp
    (defmacro print-when-true (expr print-string)
      `(when ,expr
        (print ,print-string)))

    (list (print-when-true (= 1 1) "Foo")
          (print-when-true (= 1 0) "Foo"))
  #+END_SRC

  #+RESULTS:
  | NIL | NIL |

  When using the macro we see that it works correctly. When =expr= is evaluated to =T= then the =body= is evaluated as well.
  The macro body is just a quoted S-expression (a nested list structure). The =expr= and =body= arguments just represent the lisp forms as given to the macro lambda list. Macros always generate just Lisp code, that's why the result of a macro must use a quoted expression. Quoted expressions are not evaluated. The purpose of the macro is to replace the macro use with the code the macro produces. We can expand the macro to see what it would be replaced with. Let's have a look at this:

  #+BEGIN_SRC
    CL-USER> (macroexpand-1 '(print-when-true (= 1 1) "Foo"))
    (WHEN (= 1 1) (PRINT "Foo"))
    T
    #+END_SRC

    So everywhere we have this =when-true= expression it'll be replaced with 
    
   
** packages
** symbols
** REPL interactivity
*** quicklisp
*** runtime changes

* Runtimes/compilers (CCL, SBCL, ECL, ABCL | LispWorks, Allegro)

* Debugging
** REPL driven development
** trace, …

* Error handling
** unwind-protect
** Conditions
** handler-case
** Restarts
*** handler-bind

* Image based
** manipulating data in image
** image snapshot
** load from image

* Types
** everything has a type
** create new types
** check for types
*** checktype
*** typecase
** SBCL compile type checking

* Multi dispatch

* CLOS

* Functional programming
** FSet

* Web
** cl-who / spinneret
** parenscript
