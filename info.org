#+AUTHOR: Manfred Bergmann
#+TITLE: Common Lisp - oldie but goldie
#+OPTIONS: |:t \n:t

* Intro
  This article should be a brief introduction to Common Lisp. Brief, because Common Lisp is a rather large and complex system. It has many features. I will try to concentrate on the basics and some exceptional features that you likely find nowhere else.
  
** how did I come to Common Lisp
   I have been working with various languages and runtimes since the start oif my career 22 years ago.
   Beginning of 2019 I wanted to fin something else to closely look into that is not JVM based (which I'm mostly been working with since close to 20 years starting with Java 1.1).
   For some reason, which I can't recall, I haven't been really introduced to Lisps, ever. I also can't recall why 2019 I thought that I should take a look at Lisps.
   So I took a look at Clojure first. Clojure is a great language but it was again on the JVM. I wanted something native, or at least some other runtime.
   After some excursions to Erlang, Elixir and Lisp Flavoured Erlang I finally found Common Lisp and didn't regret it.
   
** brief history
   First drafts of Common Lisp appeared 1984. While mostly a successor of Maclisp it tried to
   unify and standardize Maclisp and the various other successors of Maclisp.
   In 1994 Common Lisp was an ANSI standard.
   
** age advantages
   Since then the standard hasn't changed. That can of course be seen as a bad thing.
   But actually I believe it is a good thing. It is even today surprisingly 'modern' and has many features of todays languages, partially even more features than 'modern' languages.
   Common Lisp is a quite large and complex package. After this long time there are of course some dusty corners. But all in all it is still very attractive and has an active community.
   Because the standard didn't change since 1994 any code written since then should still be compile- and runnable on modern compilers and runtime implementarions, where there are still a few (see below).
   
* Basics
  Let me run through some of the basic features of Common Lisp. Those basic features are likely also available in other languages. Common Lisp also has some unique features that I'll be talking about later.

** TODO lists
   Since the name 'Lisp' is an abbrevation for List Processing we should have a look at lists. Lists are the corner stone of the Lisp language because every Lisp construct is a list also called s-expression.

   
** functions
   Functions are nothing special. Every language knows them. They are sometimes also known as subroutines or procedures. There are of course fine grained meaning differences but that should be the talk for some other time.

   A simple function (which does nothing) definition looks like this:

   #+BEGIN_SRC lisp
     (defun my-fun ())
     (my-fun)
   #+END_SRC

   #+RESULTS:
   : NIL

   A function in Common Lisp always returns something, even if not explicitly done. This simple function just returns ~NIL~, which in Common Lisp has two meanings. a) it has a boolean meaning of =false= and b) it means the empty list equal to ~'()~.
   
   Common Lisp provides a very sophisticated set of features to structure function arguments.

*** Mantatory arguments
    Mandatory arguments are simply added to the list construct following the function name. This list construct that represents the arguments is commonly knows as /lambda list/.
    
    #+BEGIN_SRC lisp
      (defun my-fun (arg1 arg2)
        (list arg1 arg2))
      (my-fun "Hello" "World")
    #+END_SRC

    #+RESULTS:
    | Hello | World |
    
*** Optional arguments
    Optional arguments are defined using the ~&optional~ keyword:

    #+BEGIN_SRC lisp
      (defun my-fun (arg1 &optional opt1 (opt2 "buzz" opt2-p))
        (list arg1 opt1 opt2 opt2-p))
      (list
       (my-fun "foo")
       (my-fun "foo" "bar")
       (my-fun "foo" "bar" "my-buzz"))
    #+END_SRC

    #+RESULTS:
    | foo | NIL | buzz    | NIL |
    | foo | bar | buzz    | NIL |
    | foo | bar | my-buzz | T   |

    The first optional =opt1= does not have a default value, so if undefined it'll be ~NIL~. The second optional =opt2= when undefined is populated with the given default value "buzz". The  optional ~opt2-p~ predicate indicates whether the =opt2= parameter has been given or not. Sometimes this is useful in succeeding code.
    
*** Key arguments
    =key= arguments are similar as named arguments in other languages. The ordering of =key= arguments is not important and is not enforced. They are defined with a the ~&key~ keyword:

    #+BEGIN_SRC lisp
      (defun my-fun (&key key1 (key2 "bar" key2-p))
        (list key1 key2 key2-p))
      (list
       (my-fun)
       (my-fun :key1 "foo")
       (my-fun :key1 "foo" :key2 "buzz"))
    #+END_SRC

    #+RESULTS:
    | NIL | Foo  | NIL |
    | Bar | Foo  | NIL |
    | Bar | Buzz | T   |

    =key= arguments are optional. Similarly as ~&optional~ arguments a default value can be configured and a predicate that indicates whether the parameter was provided or not. Defining =key2-p= is optional.

*** Rest arguments
    =rest= arguments are arguments that have not already been captured by mandatory, optional, or key. So they form a rest. This rest is available in the body as a list. Defined by ~rest~ keyword. =rest= arguments are sometimes usefull to pass them on to ~apply~ function.

    #+BEGIN_SRC lisp
      (defun my-fun (arg1 &optional opt1 &rest rest)
              (list arg1 opt1 rest))
      (list
       (my-fun "foo" :rest1 "rest1" :key1 "buzz")
       (my-fun "foo" "opt1" :rest1 "rest1" :key1 "buzz"))
    #+END_SRC

    #+RESULTS:
    | foo | :REST1 | (rest1 :KEY1 buzz)        |
    | foo | opt1   | (:REST1 rest1 :KEY1 buzz) |

    
*** Mixing arguments
    As you can see it is possible to mix ~optional~, ~key~ and ~rest~ arguments. However, some care must be taken with mixing =optional= and =key= because the key of the =key= argument could be taken as a the =optional= argument. Similarly with =rest= and =key= arguments as can be seen in the examples above. In most use-cases you'd either have =optional= or =key= together with madatory arguments.
   
** lambdas
   Lambdas are anonymus functions defined at runtime. Other than that they are similar to =defun=s, regular/named functions. They can be used in place of a function name like this:

   #+BEGIN_SRC lisp
     ((lambda (x) x) "foo")  ;; returns "foo"
   #+END_SRC

   #+RESULTS:
   : foo

   In which case the lambda is immediately evaluated. The function 'is applied' on the value "foo", represented as the argument x. The function then returns x.
   In other cases, i.e. when a lambda is bound to a variable one need to evaluate the lambda using =funcall=:

   #+BEGIN_SRC lisp
     (let ((my-fun (lambda (x) x)))
       (funcall my-fun "foo"))
   #+END_SRC

   #+RESULTS:
   : foo

   This is in contrast to Scheme, or other Lisp-1s, where also =my-fun= can be used in place of the function name and would just be evaluated as a function.
   Common Lisp is a Lisp-2, which means that there are separate environments for variables and functions. In the above example =my-fun= is a variable. In order to evaluate it as a function one one has to use =funcall=.

   Lambdas are first-class objects in Common Lisp which means they can be created at runtime, bound to variables and passed around as function arguments or function results:

   #+BEGIN_SRC lisp
     (defun my-lambda ()
       (lambda (y) y))
     (list (type-of (my-lambda)) 
           (funcall (my-lambda) "bar"))
   #+END_SRC

   #+RESULTS:
   | function | bar |

   The "Lambda-calculus" (Alonzo Church, 1930) is a mathematical formal system based on variables, function abstractions (lambda expressions) and applying those using substitution. This can be used for any kind of computation and is Turing machine equivalent (or can be used to simulate a Turing machine).
   So if one would stack/nest lambda expression in lambda expression in lambda expression and so on, where a lambda expression is bound to a variable and the computation of this again substitutes a variable, you could have such a lambda-calculus.
   This is of course not so practical and hard to read but this alone would be enough to calculate anything that is calculatable.
   
** macros
  Macros are an essential part in Common Lisp. One should not confuse Lisp macros with C macros which just do textual replacement. Common Lisp macros are extremely powerful.
  In short, macros are constructs that generate and/or manipulate code. Lisp macros still stand out in contrast to other languages because Lisp macros just generate and manipulate ordinary Lisp code where as other languages use an AST (Abstract Syntax Tree) representation of the code and hence the macros must deal with the AST. In Lisp, Lisp is the AST. With this Lisp is homoiconic.

  Macros are not easy to distinguish from functions. In programs one can not see the difference. Many functions could be replaced by macros. But functions can usually not replace macros. There is a fundamental difference between the two.
  The arguments to macros are not immediately evaluated but passed to the macro as data. Whereas parameters to functions are first evaluated and the result passed to the function. For example let's recreate the =when= macro:

  #+BEGIN_SRC lisp
    (defmacro my-when (expr &body body)
      `(if ,expr ,@body))
  #+END_SRC

  #+RESULTS:
  : MY-WHEN

  When using the macro it prints:

  #+BEGIN_SRC
    CL-USER> (my-when (= 1 0)
               (print "Foo"))
    NIL
    CL-USER> (my-when (= 1 1)
               (print "Foo"))
    "Foo"
  #+END_SRC

  The macro expands the =expr= and =body= arguments. Macros always generate just Lisp code, that's why the result of a macro must use a quoted expression. Quoted expressions are not evaluated, they are just plain data (a list), so the macro expression can be replaced with the macro body whereever the macro is used. We can expand the macro to see what it would be replaced with. Let's have a look at this:

  #+BEGIN_SRC
    CL-USER> (macroexpand-1 '(my-when (= 1 1)
                              (print "Foo")))
    (IF (= 1 1) (PRINT "Foo"))
  #+END_SRC

  So we see that =my-when= is replaced with an =if= special form. As we said, a quoted expression is not evaluated, so would we use the =expr= argument in the quoted expression we would just get =(IF EXPR ...)=, but we want to =expr= to be expanded here so that the right =if= form is created with what the user defined as the =if= test expression. The =,= 'escapes' the quoted expression and will expand the following form. =,expr= is thus expanded to =(= 1 1)= and =,@body= to =(print "Foo")=. The =@= is special as it unwraps (splices) a list of expressions. Since the body of a macro can denote many forms they are wrapped into a list for the =&body= argument and hence have to be unwrapped again on expansion. I.e.:

  #+BEGIN_SRC lisp
    (my-when t
      (print "Foo")
      (print "Bar"))
  #+END_SRC

  Here the two print forms represent the body of the macro and are wrapped into a list for the =&body= argument like:

  #+BEGIN_SRC lisp
    ((print "Foo")
     (print "Bar"))
  #+END_SRC

  The =@= will remove the outer list structure.

  *when are macros expanded?*

  Macros are expanded during the 'macro exansion' phase. This phase happens before compilation. So the Lisp compiler already only sees the macro expanded code.
   
** packages
  Packages are constructs to separate and structure data and code similar as in other languages. =defpackage= declares a new package. =in-package= makes the named package the current package. Any function, macro or variable definitions are then first of all local to that package where they are defined in. Function, macro or variable definitions can be exported, which means that they are then visible for/from other packages. A typical example of a package with some definitions would be:

  #+BEGIN_SRC lisp
    (defpackage :foo
      (:use :cl)
      (:import-from #:bar
                    #:bar-fun
                    #:bar-var)
      (:export #:my-fun
               #:my-var))
    (in-package :foo)

    (defparameter my-var "Foovar")
    (defun my-fun () (print "Foofun"))
    (defun my-internal-fun () (print "Internal"))
  #+END_SRC

  A package is kind of a lookup table where function names, variable names, etc., represented as symbols (later more on symbols) refer to an object which represents the function, variable, etc. The function =my-fun1= would be refered to using a package qualified name =foo:my-fun1=. The exported 'symbols' are the public interface of the package. Using a double colon one can also refer to internal symbols, like: =foo::my-internal-fun= but that should be done with care.
  It is also possible to import specific package symbols (functions, variables, etc.) by using the =import= or =import-from= functions. Any package added as parameter of =:use= will be inherited by the defined package and so all exported symbols of the packages mentioned at =:use= will be known and can be used without using the package qualified name.
  
** symbols
  Symbols in Common Lisp are almost everywhere. They represent data and are data themselves. When they represent they represent variables or functions. When used as data we can use them as identifiers or as  something like enums or other things.

  We can create symbols by just saying ='foo= in the REPL. This will create a symbol with the name "FOO". Notice the uppercase. We also create symbols by using the function =INTERN=.
  
  Let's have a look at the structure of symbols. We create a symbol from a string by using the =INTERN= function.

*** Unbound symbols
  
  #+BEGIN_SRC lisp
    (intern "foo")
  #+END_SRC

  #+RESULTS:
  : |foo|

  This symbol =foo= was created in the current package (=*package*=). We can have a look at =*package*= (in Emacs by just evaluating =*package*= and clicking on the result):

  #+BEGIN_SRC
#<PACKAGE #x30004000001D>
--------------------
Name: "COMMON-LISP-USER"
Nick names: "CL-USER"
Use list: CCL, COMMON-LISP
Used by list: 
2 present symbols.
0 external symbols.
2 internal symbols.
1739 inherited symbols.
0 shadowed symbols.
  #+END_SRC

  We'll see that there are 2 internal symbols. One of them is our newly created symbol =foo=. Let's drill further down to the internal symbols.

  #+BEGIN_SRC
#<%PACKAGE-SYMBOLS-CONTAINER #x3020014B3FCD>
--------------------
All internal symbols of package "COMMON-LISP-USER"

A symbol is considered internal of a package if it's
present and not external---that is if the package is
the home package of the symbol, or if the symbol has
been explicitly imported into the package.

Notice that inherited symbols will thus not be listed,
which deliberately deviates from the CLHS glossary
entry of `internal' because it's assumed to be more
useful this way.

  [Group by classification]

Symbols:                Flags:
----------------------- --------
foo                     --------
  #+END_SRC

  So =foo= is listed as symbol. Let's look at =foo= in detail (in Emacs we can click on =foo=).

  #+BEGIN_SRC
#<SYMBOL #x3020012F958E>
--------------------
Its name is: "foo"
It is unbound.
It has no function value.
It is internal to the package: COMMON-LISP-USER [export] [unintern]
Property list: NIL
  #+END_SRC

  Here we see the attributes of symbol =foo=. Symbols can be bound to variables, or they can have a function value (Common Lisp is a Lisp-2, which means it separates variables from function names. In a Lisp-1, like Scheme, one cannot have the same name for a variable and function), in which case they refer to a variable or function. Our symbol is neither, it's just a plain symbol.

  We can get the name of the symbol by:

  #+BEGIN_SRC lisp
    (symbol-name (intern "foo"))
  #+END_SRC

  #+RESULTS:
  : foo

*** Bound symbols
  Whenever we define a variable, or function we bind a symbol to a variable or function. Let's do this:

  #+BEGIN_SRC lisp
    ;; create a variable definition in the current package
    (defvar *X* "foo")
  #+END_SRC

  When we look again in the current package =*package*= we see an additional symbol:

  #+BEGIN_SRC
#<%PACKAGE-SYMBOLS-CONTAINER #x3020014B3FCD>
...
Symbols:                Flags:
----------------------- --------
*X*                     b-------
foo                     --------
  #+END_SRC

  And it is flagged with "b", meaning it is bound, see below.

  #+BEGIN_SRC
#<SYMBOL #x30200145E2EE>
--------------------
Its name is: "*X*"
It is a global variable bound to: "foo" [unbind]
It has no function value.
It is internal to the package: COMMON-LISP-USER [export] [unintern]
Property list: NIL
  #+END_SRC

  The same can be done with functions. Defining a function with =defun= will create a symbol in the current package whose function object is the function. Let's create a function: =(defun foo-fun ())= and look at the symbol:

  #+BEGIN_SRC
#<%PACKAGE-SYMBOLS-CONTAINER #x3020015C0E8D>
--------------------
Symbols:                Flags:
----------------------- --------
FOO-FUN                 -f------

#<SYMBOL #x3020014D1C4E>
--------------------
Its name is: "FOO-FUN"
It is unbound.
It is a function: #<Compiled-function FOO-FUN #x3020014D0A8F> [unbind]
  #+END_SRC

*** The Lisp reader
  When a Lisp file is read, or some input from the REPL, this is first of all just characters. What the /reader/ reads it turns into objects, symbols, and places those (using =INTERN=) into the current package. It also applies some rules for how the string it has read is converted to the name of a symbol. Usually those rules include turning all characters to uppercase, so a function definition of "foo" creates a symbol of =FOO=. It is possible to have symbol names with literals. We have seen that when we defined the symbol =|foo|=. The reader put vertical bars around "foo" which means the symbol name is literally "foo". This is because we have not applied the conversion rules when using =INTERN=. If we had defined the symbol as =(intern "FOO")= we wouldn't see the vertical bars.
  
** REPL interactivity
*** quicklisp
*** runtime changes

* Runtimes/compilers (CCL, SBCL, ECL, ABCL | LispWorks, Allegro)

* Debugging
** REPL driven development
** trace, â€¦

* Error handling
** unwind-protect
** Conditions
** handler-case
** Restarts
*** handler-bind

* Image based
** manipulating data in image
** image snapshot
** load from image

* Types
** everything has a type
** create new types
** check for types
*** checktype
*** typecase
** SBCL compile type checking

* Multi dispatch

* CLOS

* Functional programming
** FSet

* Web
** cl-who / spinneret
** parenscript
